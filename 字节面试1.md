基于字节跳面试贴https://www.nowcoder.com/discuss/443609?type=2&order=0&pos=1&page=1&channel=666&source_id=discuss_tag
给出的相关问题，通过资料查询、总结并汇总成本文。全文的准确性基本得到相关资料和实验的保证，
但由于本人水平有限，如有错误，请评论留言。
#### 1.1 Git相关 
* **git中的branch是什么？**  

　　branch，即分支。本身Head指针是指向master主分支的，此时如果创建一个新的branch分支的话，
会在当前节点上新增一个新的指针a，通过Head的指向来决定当前的工作区指向那个分支。
也就是说两个分支上的工作都可以进行，而且相互不产生影响。
* **reset和revert的区别？**  

　　首先谈谈reset的三个模式，hard、soft和mixed。  
hard会回滚到某个历史commit的版本，同时在这个历史版本之后提交的所有记录都会被抹除，此时工作区和暂存区都将会是clean状态。
soft的回滚是将之后提交的内容重新放回到暂存区，此时工作区的文件不会发生变化，
但是工作区和暂存区都放着回滚版本和回滚前版本的文件，而仓库区的记录已经清除。最后是mixed，
reset的默认方法，此时工作区的文件也不会发生变化，但是此时暂存区此时和仓库区的状态一致，
如果需要提交首先需要add命令，将修改内容添加到暂存区。  
　　此外值得一提的是，只有hard模式会直接恢复已经删除的文件。如果使用的是mixed模式，
此时会回退到未add状态，利用checkout语句可以找回被删除文件，也可以用add和commit提交删除操作。
如果是soft模式，此时会回退到已add状态，也就是说无法找回被删除文件，只能用commit提交，
这意味着对删除操作的soft回退基本是没有意义的，总的来说在目前的使用中尚未发掘到soft模式的用途。   
　　因此reset是版本回退，相当于仓库记录是一定会被消除；如果想保留之前的操作又希望重新回到某个版本，
此时revert就派上用场。revert的回退会保留log仓库记录。  
　　但是需要注意的是，revert的回退类似于redo，这意味着如果之前有在主线上合并过别的分支等操作，
那么revert和reset的结果会不一致。
* **rebase和merge的区别？**  

　　merge和rebase都可以将两个分支合并到一起，其最大区别在于merge以后会在master分支保留其他分支的commit，
相当于将别的分支汇总到master分支上，但不影响之前的master分支。rebase操作则是更有更换主分支的意思，
将别的分支rebase到master以后，会将master嫁接到其他分支上去，从而舍弃掉原有的master分支。
不过这两种操作均不会影响其他分支的工作。
* 为什么add和commit要分开操作？

　　git包括工作区、暂存区和仓库区三个部分，当执行add命令时，工作区变动的文件会提交到暂存区。
而使用commit命令，则是将暂存区的内容提交到仓库区保存起来。其中add不会产生唯一的commit编号，
而使用commit命令才会得到该编号。在reset的不同参数下，版本回退的程度也是和三个区域相关，
soft下需要执行commit，而mixed下需要执行add + commit。
* **如何查到某行代码错误是哪个人写的？**  

　　利用给git log -L命令可以详细去查某行代码的历史修改记录。此外还有一个git blame filename
命令记录了文件中每行最后的修改时间和修改人员。

#### 1.2 Python相关
* **python装饰器**

　　装饰器提供了一种不用和继承结构绑定的定义功能的方法，通过封装方法或者类并提供额外的功能。
标注类方法的内置装饰器包括@property、@staticmethod和@classmethod，其中@property
装饰器可以将类方法用访问类属性的方式来访问。而@staticmethod和@classmethod装饰器会将方法函数转换成类级函数，
从而可以通过类来访问而不是对象。
* **在python函数参数中，\*和\*\*的区别**

　　第一个区别在运算中，\*代表乘，而\**代表乘方；第二个区别在函数传参时，用\*传参时，
会被解析成元组类型，而用\*\*传参，则会被解析成字典类型。此外\*还在解包的时候用于收集不定长参数，
用列表的形式返回。
* **python垃圾回收机制**  

　　引用计数 + 弱引用
